#!/usr/bin/env node

import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

const CLAUDE_MD_PATH = path.join(__dirname, '..', 'CLAUDE.md');
const START_MARKER = '<!-- AUTO-GENERATED HELP START -->';
const END_MARKER = '<!-- AUTO-GENERATED HELP END -->';

async function getHelpOutput(): Promise<string> {
  try {
    const { stdout } = await execAsync('ts-node src/cli.ts --help', {
      cwd: path.join(__dirname, '..')
    });
    return stdout;
  } catch (error: any) {
    return 'Error: Could not generate help output';
  }
}

function updateClaudeMd(helpOutput: string): void {
  validateClaudeMdExists();
  let content = fs.readFileSync(CLAUDE_MD_PATH, 'utf8');
  const autoGeneratedSection = createAutoGeneratedSection(helpOutput);
  content = updateContentWithSection(content, autoGeneratedSection);
  fs.writeFileSync(CLAUDE_MD_PATH, content);
  console.log('âœ… CLAUDE.md updated with current --help output');
}

function validateClaudeMdExists(): void {
  if (!fs.existsSync(CLAUDE_MD_PATH)) {
    console.error('CLAUDE.md not found');
    process.exit(1);
  }
}

function createAutoGeneratedSection(helpOutput: string): string {
  const commands = extractCommands(helpOutput);
  return `${START_MARKER}
## Available RefakTS Commands

\`\`\`
${commands}
\`\`\`

${END_MARKER}`;
}

function extractCommands(helpOutput: string): string {
  const lines = helpOutput.split('\n');
  const commandsSection = findCommandsSection(lines);
  return formatCommandsForMarkdown(commandsSection);
}

function findCommandsSection(lines: string[]): string[] {
  const commandsStartIndex = findCommandsStartIndex(lines);
  if (commandsStartIndex === -1) return [];
  
  return extractCommandLines(lines, commandsStartIndex);
}

function findCommandsStartIndex(lines: string[]): number {
  return lines.findIndex(line => line.trim() === 'Commands:');
}

function extractCommandLines(lines: string[], startIndex: number): string[] {
  const commandLines: string[] = [];
  processLinesAfterStart(lines, startIndex, commandLines);
  return commandLines;
}

function processLinesAfterStart(lines: string[], startIndex: number, commandLines: string[]): void {
  let currentCommand = '';
  
  currentCommand = processCommandLines(lines, startIndex, currentCommand, commandLines);
  addFinalCommand(currentCommand, commandLines);
}

function processCommandLines(lines: string[], startIndex: number, currentCommand: string, commandLines: string[]): string {
  for (let i = startIndex + 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (shouldStopExtraction(line)) break;
    
    currentCommand = processCommandLine(line, currentCommand, commandLines);
  }
  return currentCommand;
}

function processCommandLine(line: string, currentCommand: string, commandLines: string[]): string {
  if (isRefactoringCommand(line)) {
    return startNewCommand(line, currentCommand, commandLines);
  } else if (isCommandDescriptionContinuation(currentCommand, line)) {
    return extendCurrentCommand(currentCommand, line);
  }
  return currentCommand;
}

function startNewCommand(line: string, currentCommand: string, commandLines: string[]): string {
  addFinalCommand(currentCommand, commandLines);
  return line;
}

function extendCurrentCommand(currentCommand: string, line: string): string {
  return currentCommand + ' ' + line;
}

function addFinalCommand(currentCommand: string, commandLines: string[]): void {
  if (currentCommand) {
    commandLines.push(currentCommand);
  }
}

function shouldStopExtraction(line: string): boolean {
  return line === '' || line.startsWith('Available refactoring commands:') || 
         line.includes('help [command]');
}

function isRefactoringCommand(line: string): boolean {
  return line.includes('[options]') && !line.includes('help [command]');
}

function isCommandDescriptionContinuation(currentCommand: string, line: string): boolean {
  return Boolean(currentCommand) && Boolean(line) && !line.includes('-h, --help');
}

function formatCommandsForMarkdown(commandLines: string[]): string {
  if (commandLines.length === 0) return 'No refactoring commands available';
  return commandLines.map(line => '- ' + line.trim()).join('\n');
}

function updateContentWithSection(content: string, section: string): string {
  const startIndex = content.indexOf(START_MARKER);
  const endIndex = content.indexOf(END_MARKER);
  
  if (startIndex !== -1 && endIndex !== -1) {
    return replaceExistingSection(content, section, startIndex, endIndex);
  } else {
    return addNewSection(content, section);
  }
}

function replaceExistingSection(content: string, section: string, startIndex: number, endIndex: number): string {
  const before = content.substring(0, startIndex);
  const after = content.substring(endIndex + END_MARKER.length);
  return before + section + after;
}

function addNewSection(content: string, section: string): string {
  const dogFoodingIndex = content.indexOf('**CRITICAL: Dog fooding**');
  if (dogFoodingIndex !== -1) {
    return insertAfterDogFooding(content, section, dogFoodingIndex);
  } else {
    return content + '\n\n' + section;
  }
}

function insertAfterDogFooding(content: string, section: string, dogFoodingIndex: number): string {
  const afterDogFooding = content.substring(dogFoodingIndex);
  const nextSectionMatch = afterDogFooding.match(/\n## /);
  
  if (nextSectionMatch) {
    return insertAtSectionBoundary(content, section, dogFoodingIndex, nextSectionMatch.index!);
  } else {
    return appendAtEnd(content, section);
  }
}

function insertAtSectionBoundary(content: string, section: string, dogFoodingIndex: number, matchIndex: number): string {
  const insertIndex = dogFoodingIndex + matchIndex;
  return content.substring(0, insertIndex) + '\n\n' + section + '\n' + content.substring(insertIndex);
}

function appendAtEnd(content: string, section: string): string {
  return content + '\n\n' + section;
}

async function main() {
  const helpOutput = await getHelpOutput();
  updateClaudeMd(helpOutput);
}

if (require.main === module) {
  main().catch(console.error);
}