#!/usr/bin/env node

import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

const CLAUDE_MD_PATH = path.join(__dirname, '..', 'CLAUDE.md');
const START_MARKER = '<!-- AUTO-GENERATED HELP START -->';
const END_MARKER = '<!-- AUTO-GENERATED HELP END -->';

async function getHelpOutput(): Promise<string> {
  try {
    const { stdout } = await execAsync('ts-node src/cli.ts --help', {
      cwd: path.join(__dirname, '..')
    });
    return stdout;
  } catch (error: any) {
    console.error('Error getting help output:', error);
    return 'Error: Could not generate help output';
  }
}

function updateClaudeMd(helpOutput: string): void {
  if (!fs.existsSync(CLAUDE_MD_PATH)) {
    console.error('CLAUDE.md not found');
    process.exit(1);
  }

  let content = fs.readFileSync(CLAUDE_MD_PATH, 'utf8');
  
  const autoGeneratedSection = `${START_MARKER}
## Available RefakTS Commands

\`\`\`
${helpOutput.trim()}
\`\`\`

${END_MARKER}`;

  // Check if markers exist
  const startIndex = content.indexOf(START_MARKER);
  const endIndex = content.indexOf(END_MARKER);
  
  if (startIndex !== -1 && endIndex !== -1) {
    // Replace existing section
    const before = content.substring(0, startIndex);
    const after = content.substring(endIndex + END_MARKER.length);
    content = before + autoGeneratedSection + after;
  } else {
    // Add new section after the "Dog fooding" section
    const dogFoodingIndex = content.indexOf('**CRITICAL: Dog fooding**');
    if (dogFoodingIndex !== -1) {
      // Find the end of the dog fooding section (next ## or end of file)
      const afterDogFooding = content.substring(dogFoodingIndex);
      const nextSectionMatch = afterDogFooding.match(/\n## /);
      
      if (nextSectionMatch) {
        const insertIndex = dogFoodingIndex + nextSectionMatch.index!;
        content = content.substring(0, insertIndex) + '\n\n' + autoGeneratedSection + '\n' + content.substring(insertIndex);
      } else {
        // Append at end
        content += '\n\n' + autoGeneratedSection;
      }
    } else {
      // Fallback: append at end
      content += '\n\n' + autoGeneratedSection;
    }
  }
  
  fs.writeFileSync(CLAUDE_MD_PATH, content);
  console.log('âœ… CLAUDE.md updated with current --help output');
}

async function main() {
  const helpOutput = await getHelpOutput();
  updateClaudeMd(helpOutput);
}

if (require.main === module) {
  main().catch(console.error);
}